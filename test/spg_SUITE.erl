%%%-------------------------------------------------------------------
%%% @author Maxim Fedorov <maximfca@gmail.com>
%%% @doc
%%%     spg (scalable groups simplified) module test, based on
%%% scenarios generated by PropEr test, that originally failed.
%%% @end
%%% -------------------------------------------------------------------
-module(spg_SUITE).
-author("maximfca@gmail.com").

%% Test server callbacks
-export([
    suite/0,
    all/0,
    groups/0,
    init_per_testcase/2,
    end_per_testcase/2
]).

%% Test cases exports
-export([
    app/0, app/1,
    spg/1,
    errors/0, errors/1,
    single/0, single/1,
    two/1,
    pg2/0, pg2/1,
    initial/1,
    netsplit/1,
    trisplit/1,
    foursplit/1,
    exchange/1,
    nolocal/1,
    double/1,
    scope_restart/1
]).

-include_lib("common_test/include/ct.hrl").
-include_lib("stdlib/include/assert.hrl").

suite() ->
    [{timetrap, {seconds, 10}}].

init_per_testcase(app, Config) ->
    Config;
init_per_testcase(TestCase, Config) ->
    {ok, _Pid} = spg:start_link(TestCase),
    Config.

end_per_testcase(app, _Config) ->
    application:stop(spg),
    ok;
end_per_testcase(TestCase, _Config) ->
    gen_server:stop(TestCase),
    ok.

all() ->
    [app, {group, basic}, {group, cluster}].

groups() -> 
    [
        {basic, [parallel], [errors, spg, single, pg2]},
        {cluster, [sequential], [two, initial, netsplit, trisplit, foursplit, exchange, nolocal, double, scope_restart]}
    ].


-define (do(What, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME))).
-define (do(What, Arg, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME, Arg))).
-define (do(What, Arg1, Arg2, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME, Arg1, Arg2))).

sync(GS) ->
    _ = sys:log(GS, get).

%%--------------------------------------------------------------------
%% TEST CASES

spg(_Config) ->
    ?assertMatch({error, _}, spg:start_link()),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, self())),
    ?assertEqual([self()], spg:get_local_members(?FUNCTION_NAME)),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, self())),
    ?assertEqual([], spg:get_members(?FUNCTION_NAME)),
    ?assertEqual([], spg:which_groups()).

app() ->
    [{doc, "Tests application start/stop functioning, supervision & scopes"}].

app(_Config) ->
    {ok, _Apps} = application:ensure_all_started(spg),
    ?assertNotEqual(undefined, whereis(spg)),
    ?assertNotEqual(undefined, ets:whereis(spg)),
    ok = application:stop(spg),
    ?assertEqual(undefined, whereis(spg)),
    ?assertEqual(undefined, ets:whereis(spg)),
    %
    application:set_env(spg, scopes, [?FUNCTION_NAME, two]),
    {ok, _Apps} = application:ensure_all_started(spg),
    ?assertNotEqual(undefined, whereis(?FUNCTION_NAME)),
    ?assertNotEqual(undefined, whereis(two)),
    ?assertNotEqual(undefined, ets:whereis(?FUNCTION_NAME)),
    ?assertNotEqual(undefined, ets:whereis(two)),
    application:stop(spg),
    ?assertEqual(undefined, whereis(?FUNCTION_NAME)),
    ?assertEqual(undefined, whereis(two)).

errors() ->
    [{doc, "Tests that errors are handled as expected, for example spg crashes when it needs to"}].

errors(_Config) ->
    % kill with 'info' and 'cast'
    {ok, _Pid} = spg:start(info),
    ?assertException(error, badarg, spg:handle_info(garbage, garbage)),
    ?assertException(error, badarg, spg:handle_cast(garbage, garbage)),
    % kill with call
    {ok, Pid} = spg:start(second),
    ?assertException(exit, {{badarg, _}, _}, gen_server:call(Pid, garbage, 100)).

single() ->
    [{doc, "Tests single node groups"}, {timetrap, {seconds, 5}}].

single(Config) when is_list(Config) ->
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ?do(join, ?FUNCTION_NAME, self(), ok),
    ?do(join, ?FUNCTION_NAME, [self(), self()], ok),
    ?do(get_local_members, ?FUNCTION_NAME, [self(), self(), self()]),
    ?do(get_members, ?FUNCTION_NAME, [self(), self(), self()]),
    ?do(leave, '$missing$', self(), ok),
    ?do(leave, ?FUNCTION_NAME, [self(), self()], ok),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    %
    ?do(join, ?FUNCTION_NAME, [self(), self()], ok),
    ?do(leave, ?FUNCTION_NAME, [self(), self()], ok),
    ?do(get_members, ?FUNCTION_NAME, []),
    % double
    ?do(join, ?FUNCTION_NAME, self(), ok),
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?assertEqual(lists:sort([Pid, self()]), lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    ?assertEqual(lists:sort([Pid, self()]), lists:sort(spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    %
    spgt:stop_proc(Pid),
    sync(?FUNCTION_NAME),
    ?assertEqual([self()], spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    ok.

two(Config) when is_list(Config) ->
    {TwoPeer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?do(get_local_members, ?FUNCTION_NAME, [Pid]),
    % first RPC must be serialised
    sync({?FUNCTION_NAME, TwoPeer}),
    ?assertEqual([Pid], rpc:call(TwoPeer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ?assertEqual([], rpc:call(TwoPeer, spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_proc(Pid),
    % again, must be serialised
    sync(?FUNCTION_NAME),
    ?assertEqual([], spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    ?assertEqual([], rpc:call(TwoPeer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    %
    Pid2 = spgt:spawn(TwoPeer),
    Pid3 = spgt:spawn(TwoPeer),
    ?assertEqual(ok, rpc:call(TwoPeer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
    ?assertEqual(ok, rpc:call(TwoPeer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid3])),
    % serialise through the *other* node
    sync({?FUNCTION_NAME, TwoPeer}),
    ?assertEqual(lists:sort([Pid2, Pid3]),
        lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    % stop the peer
    spgt:stop_node(TwoPeer, Socket),
    % hope that 'nodedown' comes before we route our request
    sync(?FUNCTION_NAME),
    ?assertEqual([], spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    ok.

pg2() ->
    [{doc, "Supposed to test pg2 compatibility, but since it is missing, test is just doing a few calls"}].

pg2(Config) when is_list(Config) ->
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ?do(join, ?FUNCTION_NAME, self(), ok),
    ?do(get_local_members, ?FUNCTION_NAME, [self()]),
    ?do(get_members, ?FUNCTION_NAME, [self()]),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ok.

initial(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?do(get_local_members, ?FUNCTION_NAME, [Pid]),
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    % first RPC must be serialised
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual([Pid], rpc:call(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    %
    ?assertEqual([], rpc:call(Peer, spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_proc(Pid),
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual([], rpc:call(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_node(Peer, Socket),
    ok.

netsplit(Config) when is_list(Config) ->
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    ?assertEqual(Peer, spgt:rpc(Socket, erlang, node, [])), % just to test RPC
    RemoteOldPid = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
    % hohoho, partition!
    erlang:disconnect_node(Peer),
    ?assertEqual(Peer, spgt:rpc(Socket, erlang, node, [])), % just to ensure RPC still works
    RemotePid = spgt:rpc(Socket, spgt, spawn, []),
    ?assertEqual([], spgt:rpc(Socket, erlang, nodes, [])),
    ?assertEqual(ok, spgt:rpc(Socket, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])), % join - in a partition!
    %
    ?assertEqual(ok, spgt:rpc(Socket, spg, leave, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
    ?assertEqual(ok, spgt:rpc(Socket, spg, join, [?FUNCTION_NAME, '$visible', RemoteOldPid])),
    ?assertEqual([RemoteOldPid], spgt:rpc(Socket, spg, get_local_members, [?FUNCTION_NAME, '$visible'])),
    % join locally too
    LocalPid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, LocalPid, ok),
    %
    ?assertNot(lists:member(Peer, nodes())), % should be no nodes in the cluster
    %
    pong = net_adm:ping(Peer),
    % now ensure sync happened
    Pids = lists:sort([RemotePid, LocalPid]),
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual(Pids, lists:sort(rpc:call(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]))),
    ?assertEqual([RemoteOldPid], spg:get_members(?FUNCTION_NAME, '$visible')),
    spgt:stop_node(Peer, Socket),
    ok.

trisplit(Config) when is_list(Config) ->
    {Peer, Socket1} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    _PeerPid1 = spgt:spawn(Peer),
    PeerPid2 = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, three, PeerPid2])),
    erlang:disconnect_node(Peer),
    timer:sleep(10), % needed to give net_kernel time to disconnect
    ?assertEqual(true, net_kernel:connect_node(Peer)),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, one, PeerPid2])),
    % now ensure sync happened
    {Peer2, Socket2} = spgt:spawn_node(?FUNCTION_NAME, second),
    ?assertEqual(true, rpc:call(Peer2, net_kernel, connect_node, [Peer])),
    ?assertEqual(lists:sort([node(), Peer]), lists:sort(rpc:call(Peer2, erlang, nodes, []))),
    sync({?FUNCTION_NAME, Peer2}),
    ?assertEqual([PeerPid2], rpc:call(Peer2, spg, get_members, [?FUNCTION_NAME, one])),
    spgt:stop_node(Peer, Socket1),
    spgt:stop_node(Peer2, Socket2),
    ok.

foursplit(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, one, Pid)),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, two, Pid)),
    PeerPid1 = spgt:spawn(Peer),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, one, Pid)),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, three, Pid)),
    erlang:disconnect_node(Peer),
    ?assertEqual(ok, spgt:rpc(Socket, spgt, stop_proc, [PeerPid1])),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, three, Pid)),
    ?assertEqual(true, net_kernel:connect_node(Peer)),
    ?assertEqual([], spg:get_members(?FUNCTION_NAME, one)),
    ?assertEqual([], spgt:rpc(Socket, spg, get_members, [?FUNCTION_NAME, one])),
    spgt:stop_node(Peer, Socket),
    ok.

exchange(Config) when is_list(Config) ->
    {Peer1, Socket1} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    {Peer2, Socket2} = spgt:spawn_node(?FUNCTION_NAME, second),
    Pids10 = [spgt:rpc(Socket1, spgt, spawn, []) || _ <- lists:seq(1, 10)],
    Pids2 = [spgt:rpc(Socket2, spgt, spawn, []) || _ <- lists:seq(1, 10)],
    Pids11 = [spgt:rpc(Socket1, spgt, spawn, []) || _ <- lists:seq(1, 10)],
    % kill first 3 pids from node1
    {PidsToKill, Pids1} = lists:split(3, Pids10),
    %
    ?assertEqual(ok, spgt:rpc(Socket1, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pids10])),
    sync({?FUNCTION_NAME, Peer1}),
    ?assertEqual(lists:sort(Pids10), lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    [spgt:rpc(Socket1, spgt, stop_proc, [Pid]) || Pid <- PidsToKill],
    sync(?FUNCTION_NAME),
    sync({?FUNCTION_NAME, Peer1}),
    %
    Pids = lists:sort(Pids1 ++ Pids2 ++ Pids11),
    ?assert(lists:all(fun erlang:is_pid/1, Pids)),
    %
    erlang:disconnect_node(Peer1),
    erlang:disconnect_node(Peer2),
    %
    timer:sleep(5),
    %
    sync(?FUNCTION_NAME),
    ?assertEqual([], lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    %
    [?assertEqual(ok, spgt:rpc(Socket2, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid])) || Pid <- Pids2],
    [?assertEqual(ok, spgt:rpc(Socket1, spg, join, [?FUNCTION_NAME, second, Pid])) || Pid <- Pids11],
    ?assertEqual(ok, spgt:rpc(Socket1, spg, join, [?FUNCTION_NAME, third, Pids11])),
    % rejoin
    ?assertEqual(true, net_kernel:connect_node(Peer1)),
    ?assertEqual(true, net_kernel:connect_node(Peer2)),
    % need to sleep longer to ensure both nodes made the exchange
    sync(?FUNCTION_NAME),
    sync({?FUNCTION_NAME, Peer1}),
    sync({?FUNCTION_NAME, Peer2}),
    ?assertEqual(Pids, lists:sort(spg:get_members(?FUNCTION_NAME, second) ++ spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    ?assertEqual(lists:sort(Pids11), lists:sort(spg:get_members(?FUNCTION_NAME, third))),
    %
    {Left, Stay} = lists:split(3, Pids11),
    ?assertEqual(ok, spgt:rpc(Socket1, spg, leave, [?FUNCTION_NAME, third, Left])),
    sync({?FUNCTION_NAME, Peer1}),
    sync(?FUNCTION_NAME),
    ?assertEqual(lists:sort(Stay), lists:sort(spg:get_members(?FUNCTION_NAME, third))),
    ?assertEqual(ok, spgt:rpc(Socket1, spg, leave, [?FUNCTION_NAME, left, Stay])),
    ?assertEqual(ok, spgt:rpc(Socket1, spg, leave, [?FUNCTION_NAME, third, Stay])),
    ?assertEqual([], lists:sort(spg:get_members(?FUNCTION_NAME, third))),
    sync({?FUNCTION_NAME, Peer1}),
    sync(?FUNCTION_NAME),
    %
    spgt:stop_node(Peer1, Socket1),
    spgt:stop_node(Peer2, Socket2),
    ok.

nolocal(Config) when is_list(Config) ->
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    RemotePid = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
    ?assertEqual([], spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    spgt:stop_node(Peer, Socket),
    ok.

double(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    ?do(join, ?FUNCTION_NAME, [Pid], ok),
    ?assertEqual([Pid, Pid], spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    sync(?FUNCTION_NAME),
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual([Pid, Pid], rpc:call(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_node(Peer, Socket),
    ok.

scope_restart(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, [Pid, Pid], ok),
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    RemotePid = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual(lists:sort([RemotePid, Pid, Pid]), lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    % stop scope locally, and restart
    gen_server:stop(?FUNCTION_NAME),
    spg:start(?FUNCTION_NAME),
    % ensure remote pids joined, local are missing
    sync(?FUNCTION_NAME),
    sync({?FUNCTION_NAME, Peer}),
    ?assertEqual([RemotePid], spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    spgt:stop_node(Peer, Socket),
    ok.
