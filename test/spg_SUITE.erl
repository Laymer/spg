%%%-------------------------------------------------------------------
%%% @author Maxim Fedorov <maximfca@gmail.com>
%%% @doc
%%%     spg (scalable groups simplified) module test, based on
%%% scenarios generated by PropEr test, that originally failed.
%%% @end
%%% -------------------------------------------------------------------
-module(spg_SUITE).
-author("maximfca@gmail.com").

%% Test server callbacks
-export([
    suite/0,
    all/0,
    groups/0,
    init_per_testcase/2,
    end_per_testcase/2
]).

%% Test cases exports
-export([
    spg/1,
    single/0, single/1,
    two/1,
    pg2/0, pg2/1,
    initial/1,
    netsplit/1,
    trisplit/1,
    foursplit/1,
    nolocal/1
]).

-include_lib("common_test/include/ct.hrl").
-include_lib("stdlib/include/assert.hrl").

suite() ->
    [{timetrap, {seconds, 10}}].

init_per_testcase(TestCase, Config) ->
    {ok, _Pid} = spg:start_link(TestCase),
    Config.

end_per_testcase(TestCase, _Config) ->
    test_server_ctrl:kill_slavenodes(),
    gen_server:stop(TestCase),
    ok.

all() ->
    [{group, basic}, {group, cluster}].

groups() -> 
    [
        {basic, [parallel], [spg, single, pg2]},
        {cluster, [sequential], [two, initial, netsplit, trisplit, foursplit, nolocal]}
    ].

%%--------------------------------------------------------------------
%% TEST CASES

spg(_Config) ->
    ?assertMatch({error, _}, spg:start_link()),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, self())),
    ?assertEqual([self()], spg:get_local_members(?FUNCTION_NAME)),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, self())),
    ?assertEqual([], spg:get_members(?FUNCTION_NAME)),
    ?assertEqual([], spg:which_groups()).

-define (do(What, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME))).
-define (do(What, Arg, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME, Arg))).
-define (do(What, Arg1, Arg2, Expect), ?assertEqual(Expect, spg:What(?FUNCTION_NAME, Arg1, Arg2))).

-define (route(M, F, A), gen_server:call(?FUNCTION_NAME, {route, {M, F, A}})).
-define (route_rpc(Node, M, F, Args), gen_server:call(?FUNCTION_NAME, {route, {rpc, call, [Node, M, F, Args, 5000]}})).
-define (rpc_route(Node, M, F, Args), gen_server:call(?FUNCTION_NAME, {route, {gen_server, call, [{?FUNCTION_NAME, Node}, {route, {M, F, Args}}]}})).

single() ->
    [{doc, "Tests single node groups"}, {timetrap, {seconds, 5}}].

single(Config) when is_list(Config) ->
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ?do(join, ?FUNCTION_NAME, self(), ok),
    ?do(join, ?FUNCTION_NAME, self(), ok),
    ?do(get_local_members, ?FUNCTION_NAME, [self(), self()]),
    ?do(get_members, ?FUNCTION_NAME, [self(), self()]),
    ?do(leave, '$missing$', self(), ok),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    % double
    ?do(join, ?FUNCTION_NAME, self(), ok),
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?assertEqual(lists:sort([Pid, self()]), lists:sort(spg:get_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    ?assertEqual(lists:sort([Pid, self()]), lists:sort(spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME))),
    %
    spgt:stop_proc(Pid),
    ?assertEqual([self()], ?route(spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ok.

two(Config) when is_list(Config) ->
    {TwoPeer, _Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?do(get_local_members, ?FUNCTION_NAME, [Pid]),
    % first RPC must be serialised
    ?assertEqual([Pid], ?route_rpc(TwoPeer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ?assertEqual([], rpc:call(TwoPeer, spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_proc(Pid),
    % again, must be serialised
    ?assertEqual([], ?route(spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ?assertEqual([], rpc:call(TwoPeer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    %
    Pid2 = spgt:spawn(TwoPeer),
    Pid3 = spgt:spawn(TwoPeer),
    ?assertEqual(ok, rpc:call(TwoPeer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid2])),
    ?assertEqual(ok, rpc:call(TwoPeer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, Pid3])),
    % serialise through the *other* node
    ?assertEqual(lists:sort([Pid2, Pid3]),
        lists:sort(?route_rpc(TwoPeer, rpc, call, [node(), spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]]))),
    % stop the peer
    spgt:stop_node(TwoPeer),
    % hope that 'nodedown' comes before we route our request
    ?assertEqual([], ?route(spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ok.

pg2() ->
    [{doc, "Supposed to test pg2 compatibility, but since it is missing, test is just doing a few calls"}].

pg2(Config) when is_list(Config) ->
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ?do(join, ?FUNCTION_NAME, self(), ok),
    ?do(get_local_members, ?FUNCTION_NAME, [self()]),
    ?do(get_members, ?FUNCTION_NAME, [self()]),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(leave, ?FUNCTION_NAME, self(), ok),
    ?do(which_groups, []),
    ?do(get_local_members, ?FUNCTION_NAME, []),
    ?do(get_members, ?FUNCTION_NAME, []),
    ok.

initial(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, Pid, ok),
    ?do(get_local_members, ?FUNCTION_NAME, [Pid]),
    {Peer, _Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    % first RPC must be serialised
    ?assertEqual([Pid], ?route_rpc(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    %
    ?assertEqual([], rpc:call(Peer, spg, get_local_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    spgt:stop_proc(Pid),
    ?assertEqual([], ?route_rpc(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME])),
    ok.

netsplit(Config) when is_list(Config) ->
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    ?assertEqual(Peer, spgt:rpc(Socket, erlang, node, [])), % just to test RPC
    RemoteOldPid = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
    % hohoho, partition!
    erlang:disconnect_node(Peer),
    ?assertEqual(Peer, spgt:rpc(Socket, erlang, node, [])), % just to ensure RPC still works
    RemotePid = spgt:rpc(Socket, spgt, spawn, []),
    ?assertEqual([], spgt:rpc(Socket, erlang, nodes, [])),
    ?assertEqual(ok, spgt:rpc(Socket, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])), % join - in a partition!
    %
    ?assertEqual(ok, spgt:rpc(Socket, spg, leave, [?FUNCTION_NAME, '$invisible', RemoteOldPid])),
    ?assertEqual(ok, spgt:rpc(Socket, spg, join, [?FUNCTION_NAME, '$visible', RemoteOldPid])),
    ?assertEqual([RemoteOldPid], spgt:rpc(Socket, spg, get_local_members, [?FUNCTION_NAME, '$visible'])),
    % join locally too
    LocalPid = spgt:spawn(),
    ?do(join, ?FUNCTION_NAME, LocalPid, ok),
    %
    ?assertEqual([], nodes()), % should be no nodes in the cluster
    %
    pong = net_adm:ping(Peer),
    % now ensure sync happened
    Pids = lists:sort([RemotePid, LocalPid]),
    ?assertEqual(Pids, lists:sort(?route_rpc(Peer, spg, get_members, [?FUNCTION_NAME, ?FUNCTION_NAME]))),
    ?assertEqual([RemoteOldPid], spg:get_members(?FUNCTION_NAME, '$visible')),
    ok.

trisplit(Config) when is_list(Config) ->
    {Peer, _Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    _PeerPid1 = spgt:spawn(Peer),
    PeerPid2 = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, three, PeerPid2])),
    erlang:disconnect_node(Peer),
    ?assertEqual(true, net_kernel:connect_node(Peer)),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, one, PeerPid2])),
    % now ensure sync happened
    {Peer2, _Socket2} = spgt:spawn_node(?FUNCTION_NAME, second),
    ?assertEqual(true, rpc:call(Peer2, net_kernel, connect_node, [Peer])),
    ?assertEqual(lists:sort([node(), Peer]), lists:sort(rpc:call(Peer2, erlang, nodes, []))),
    ?assertEqual([PeerPid2], ?rpc_route(Peer2, spg, get_members, [?FUNCTION_NAME, one])),
    ok.

foursplit(Config) when is_list(Config) ->
    Pid = spgt:spawn(),
    {Peer, Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, one, Pid)),
    ?assertEqual(ok, spg:join(?FUNCTION_NAME, two, Pid)),
    PeerPid1 = spgt:spawn(Peer),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, one, Pid)),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, three, Pid)),
    erlang:disconnect_node(Peer),
    ?assertEqual(ok, spgt:rpc(Socket, spgt, stop_proc, [PeerPid1])),
    ?assertEqual(ok, spg:leave(?FUNCTION_NAME, three, Pid)),
    ?assertEqual(true, net_kernel:connect_node(Peer)),
    ?assertEqual([], spg:get_members(?FUNCTION_NAME, one)),
    ?assertEqual([], spgt:rpc(Socket, spg, get_members, [?FUNCTION_NAME, one])),
    ok.

nolocal(Config) when is_list(Config) ->
    {Peer, _Socket} = spgt:spawn_node(?FUNCTION_NAME, ?FUNCTION_NAME),
    RemotePid = spgt:spawn(Peer),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
    ?assertEqual(ok, rpc:call(Peer, spg, join, [?FUNCTION_NAME, ?FUNCTION_NAME, RemotePid])),
    ?assertEqual([], spg:get_local_members(?FUNCTION_NAME, ?FUNCTION_NAME)),
    ok.
